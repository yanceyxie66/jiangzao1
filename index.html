<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 创意绘图实验室 | GenAI Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0;
        }

        .canvas-container {
            background-image: 
                linear-gradient(45deg, #1e293b 25%, transparent 25%), 
                linear-gradient(-45deg, #1e293b 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #1e293b 75%), 
                linear-gradient(-45deg, transparent 75%, #1e293b 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* 隐藏滚动条但保持功能 */
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .tool-btn.active {
            background-color: #3b82f6; /* Blue 500 */
            color: white;
            border-color: #3b82f6;
        }

        /* 加载动画 */
        .cyber-loader {
            width: 48px;
            height: 48px;
            border: 4px solid #3b82f6;
            border-bottom-color: transparent;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- 顶部导航 -->
    <header class="bg-slate-800 border-b border-slate-700 h-16 flex items-center justify-between px-6 shrink-0">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 p-2 rounded-lg">
                <i class="fas fa-magic text-white"></i>
            </div>
            <h1 class="text-xl font-bold tracking-wide">AI 创意绘图实验室</h1>
        </div>
        <!-- 删除了设置按钮，因为不需要前端填 Key 了 -->
    </header>

    <!-- 主工作区 -->
    <main class="flex-1 flex overflow-hidden">
        
        <!-- 左侧工具栏 -->
        <aside class="w-80 bg-slate-900 border-r border-slate-800 flex flex-col p-5 gap-6 z-10 shadow-xl overflow-y-auto hide-scrollbar">
            
            <!-- 步骤 1: 上传 -->
            <div class="step-group">
                <h3 class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">步骤 1: 选择素材</h3>
                <div class="border-2 border-dashed border-slate-600 rounded-xl p-6 text-center hover:border-blue-500 transition-colors cursor-pointer bg-slate-800/50" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-cloud-upload-alt text-3xl text-slate-400 mb-2"></i>
                    <p class="text-sm text-slate-300">点击上传图片</p>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </div>
            </div>

            <!-- 步骤 2: 涂抹 -->
            <div class="step-group">
                <h3 class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">步骤 2: 定义区域</h3>
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button id="btnBrush" class="tool-btn active flex items-center justify-center gap-2 py-2 px-4 rounded-lg border border-slate-600 bg-slate-800 hover:bg-slate-700 transition-all text-sm" onclick="setTool('brush')">
                        <i class="fas fa-paint-brush"></i> 涂抹
                    </button>
                    <button id="btnEraser" class="tool-btn flex items-center justify-center gap-2 py-2 px-4 rounded-lg border border-slate-600 bg-slate-800 hover:bg-slate-700 transition-all text-sm" onclick="setTool('eraser')">
                        <i class="fas fa-eraser"></i> 擦除
                    </button>
                </div>
                
                <div class="bg-slate-800 p-3 rounded-lg border border-slate-700">
                    <label class="flex justify-between text-xs text-slate-400 mb-2">
                        <span>笔刷大小</span>
                        <span id="brushSizeVal">20px</span>
                    </label>
                    <input type="range" id="brushSize" min="5" max="100" value="20" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <button onclick="clearMask()" class="w-full mt-2 py-2 text-xs text-red-400 hover:text-red-300 border border-transparent hover:border-red-900/30 rounded transition-colors">
                    <i class="fas fa-trash-alt mr-1"></i> 清空涂抹区域
                </button>
            </div>

            <!-- 步骤 3: 提示词 -->
            <div class="step-group flex-1">
                <h3 class="text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">步骤 3: 创意描述</h3>
                <textarea id="promptInput" class="w-full h-32 bg-slate-800 border border-slate-700 rounded-lg p-3 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none resize-none text-slate-200" placeholder="描述你想要在涂抹区域生成的内容...&#10;例如：一只戴着墨镜的猫，赛博朋克风格"></textarea>
            </div>

            <!-- 启动按钮 -->
            <button id="generateBtn" onclick="startGeneration()" class="w-full py-4 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 rounded-xl font-bold text-white shadow-lg shadow-blue-900/20 transform transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                <i class="fas fa-sparkles"></i> 启动生成
            </button>
        </aside>

        <!-- 中间画布区 -->
        <section class="flex-1 bg-slate-950 relative flex items-center justify-center p-8 overflow-hidden">
            
            <!-- 画布包装器 -->
            <div id="canvasWrapper" class="relative shadow-2xl rounded-lg overflow-hidden border border-slate-700 canvas-container" style="width: 512px; height: 512px;">
                <!-- 1. 底图层 -->
                <canvas id="baseCanvas" width="512" height="512" class="absolute top-0 left-0"></canvas>
                <!-- 2. 仿真去噪层 (用于动画演示) -->
                <canvas id="simulationCanvas" width="512" height="512" class="absolute top-0 left-0 pointer-events-none opacity-0 transition-opacity duration-500"></canvas>
                <!-- 3. 结果层 (API返回后显示) -->
                <canvas id="resultCanvas" width="512" height="512" class="absolute top-0 left-0 opacity-0 transition-opacity duration-1000"></canvas>
                <!-- 4. 蒙版交互层 (最顶层，处理鼠标事件) -->
                <canvas id="maskCanvas" width="512" height="512" class="absolute top-0 left-0 cursor-crosshair opacity-70"></canvas>
                
                <!-- 空状态提示 -->
                <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-slate-500 pointer-events-none bg-slate-900/80 backdrop-blur-sm z-50">
                    <i class="fas fa-image text-5xl mb-4 opacity-50"></i>
                    <p class="text-lg font-medium">请先上传一张图片</p>
                </div>

                <!-- 加载/处理状态遮罩 -->
                <div id="loadingOverlay" class="absolute inset-0 bg-black/60 backdrop-blur-sm z-[60] hidden flex-col items-center justify-center">
                    <div class="cyber-loader mb-4"></div>
                    <h2 class="text-xl font-bold text-white mb-1" id="loadingText">正在初始化...</h2>
                    <p class="text-sm text-blue-300" id="loadingSubText">连接云端计算集群</p>
                </div>
            </div>

            <!-- 状态信息条 -->
            <div class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-slate-800/90 backdrop-blur border border-slate-700 px-6 py-2 rounded-full text-sm flex items-center gap-3 shadow-lg">
                <span id="statusDot" class="w-2 h-2 rounded-full bg-slate-500"></span>
                <span id="statusText">等待操作...</span>
            </div>

        </section>
    </main>

<script>
    // ================= 全局变量 =================
    const canvasSize = 512;
    const baseCanvas = document.getElementById('baseCanvas');
    const maskCanvas = document.getElementById('maskCanvas');
    const simulationCanvas = document.getElementById('simulationCanvas');
    const resultCanvas = document.getElementById('resultCanvas');
    
    const ctxBase = baseCanvas.getContext('2d');
    const ctxMask = maskCanvas.getContext('2d');
    const ctxSim = simulationCanvas.getContext('2d');
    const ctxResult = resultCanvas.getContext('2d');

    let isDrawing = false;
    let currentTool = 'brush'; // brush or eraser
    let brushSize = 20;
    let hasImage = false;
    let isGenerating = false;

    // ================= 初始化 =================
    function init() {
        // 绑定笔刷大小滑块
        const range = document.getElementById('brushSize');
        range.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeVal').innerText = brushSize + 'px';
        });

        maskCanvas.addEventListener('mousedown', startDraw);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDraw);
        maskCanvas.addEventListener('mouseleave', stopDraw);

        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
    }

    // ================= 图像处理逻辑 =================
    function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                // 居中缩放绘制
                ctxBase.clearRect(0, 0, canvasSize, canvasSize);
                
                // contain 模式
                const scale = Math.min(canvasSize / img.width, canvasSize / img.height);
                const x = (canvasSize - img.width * scale) / 2;
                const y = (canvasSize - img.height * scale) / 2;
                
                ctxBase.drawImage(img, x, y, img.width * scale, img.height * scale);
                
                // 重置其他层
                clearMask();
                ctxSim.clearRect(0, 0, canvasSize, canvasSize);
                ctxResult.clearRect(0, 0, canvasSize, canvasSize);
                resultCanvas.style.opacity = '0';
                
                hasImage = true;
                document.getElementById('emptyState').classList.add('hidden');
                updateStatus('图片已就绪，请涂抹需要修改的区域', 'green');
            }
            img.src = event.target.result;
        }
        reader.readAsDataURL(file);
    }

    // ================= 绘图逻辑 (Mask) =================
    function startDraw(e) {
        if (!hasImage || isGenerating) return;
        isDrawing = true;
        draw(e);
    }

    function draw(e) {
        if (!isDrawing) return;

        const rect = maskCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvasSize / rect.width);
        const y = (e.clientY - rect.top) * (canvasSize / rect.height);

        ctxMask.lineWidth = brushSize;
        ctxMask.lineCap = 'round';
        ctxMask.lineJoin = 'round';

        if (currentTool === 'brush') {
            ctxMask.globalCompositeOperation = 'source-over';
            ctxMask.strokeStyle = 'rgba(255, 0, 0, 0.6)'; // 半透明红色
        } else {
            ctxMask.globalCompositeOperation = 'destination-out';
            ctxMask.strokeStyle = 'rgba(0,0,0,1)';
        }

        ctxMask.lineTo(x, y);
        ctxMask.stroke();
        ctxMask.beginPath();
        ctxMask.moveTo(x, y);
    }

    function stopDraw() {
        isDrawing = false;
        ctxMask.beginPath();
    }

    function setTool(tool) {
        currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(tool === 'brush' ? 'btnBrush' : 'btnEraser').classList.add('active');
    }

    function clearMask() {
        ctxMask.clearRect(0, 0, canvasSize, canvasSize);
    }

    // ================= 核心流程：生成与仿真 =================
    async function startGeneration() {
        if (!hasImage) return alert('请先上传图片');
        const prompt = document.getElementById('promptInput').value.trim();
        if (!prompt) return alert('请输入提示词');

        const maskData = ctxMask.getImageData(0, 0, canvasSize, canvasSize);
        const hasMaskPixel = maskData.data.some((val, index) => index % 4 === 3 && val > 0);
        if (!hasMaskPixel) return alert('请先用画笔涂抹需要修改的区域');

        isGenerating = true;
        document.getElementById('generateBtn').disabled = true;
        
        // 1. 准备 UI
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const loadingSubText = document.getElementById('loadingSubText');
        
        loadingOverlay.classList.remove('hidden');
        loadingOverlay.classList.add('flex');
        
        try {
            // 2. 准备发送给 AI 的图片
            const inputCanvas = document.createElement('canvas');
            inputCanvas.width = canvasSize;
            inputCanvas.height = canvasSize;
            const ctxInput = inputCanvas.getContext('2d');
            
            // 绘制底图
            ctxInput.drawImage(baseCanvas, 0, 0);
            
            // 绘制涂抹层
            const tempMaskCanvas = document.createElement('canvas');
            tempMaskCanvas.width = canvasSize;
            tempMaskCanvas.height = canvasSize;
            const tCtx = tempMaskCanvas.getContext('2d');
            tCtx.drawImage(maskCanvas, 0, 0);
            const mData = tCtx.getImageData(0, 0, canvasSize, canvasSize);
            for(let i=0; i<mData.data.length; i+=4) {
                if(mData.data[i+3] > 50) { 
                    mData.data[i] = 255;   
                    mData.data[i+1] = 0;   
                    mData.data[i+2] = 0;   
                    mData.data[i+3] = 255; 
                }
            }
            tCtx.putImageData(mData, 0, 0);
            ctxInput.drawImage(tempMaskCanvas, 0, 0);

            const base64Image = inputCanvas.toDataURL('image/png'); 

            // 3. 启动“仿真去噪动画”
            maskCanvas.style.opacity = '0'; 
            simulationCanvas.style.opacity = '1';
            
            let animationFrameId;
            let progress = 0;
            const animateDiffusion = () => {
                if(progress > 100) progress = 100;
                
                const imgData = ctxSim.createImageData(canvasSize, canvasSize);
                const buffer = new Uint32Array(imgData.data.buffer);
                
                for(let i=0; i<buffer.length; i++) {
                    const alpha = mData.data[i*4+3]; 
                    if(alpha > 50) {
                        const noiseAmount = Math.max(0, 1 - progress/80); 
                        const r = Math.random() * 255 * noiseAmount;
                        const g = Math.random() * 255 * noiseAmount;
                        const b = Math.random() * 255 * noiseAmount;
                        
                        imgData.data[i*4] = r + (progress * 2); 
                        imgData.data[i*4+1] = g + (progress * 2);
                        imgData.data[i*4+2] = b + (progress * 2);
                        imgData.data[i*4+3] = 255;
                    } else {
                        imgData.data[i*4+3] = 0; 
                    }
                }
                ctxSim.putImageData(imgData, 0, 0);
                
                loadingText.innerText = `AI 正在构思... ${Math.floor(progress)}%`;
                loadingSubText.innerText = progress < 50 ? "正向扩散：添加噪声" : "反向去噪：重构图像";
                
                if(isGenerating) {
                    progress += 0.5; 
                    animationFrameId = requestAnimationFrame(animateDiffusion);
                }
            };
            animateDiffusion();

            // 4. 调用后端代理 (完美解决 CORS)
            updateStatus('正在连接服务器...', 'blue');
            
            const augmentedPrompt = `将图中红色涂抹的区域替换为：${prompt}。保持图像其他部分不变，融合自然。`;

            // 请求自己的后端接口
            const response = await fetch('/api/generate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    "model": "qwen-image-edit-plus",
                    "input": {
                        "messages": [
                            {
                                "role": "user",
                                "content": [
                                    { "image": base64Image }, 
                                    { "text": augmentedPrompt }
                                ]
                            }
                        ]
                    },
                    "parameters": {
                        "n": 1,
                        "watermark": false
                    }
                })
            });

            const data = await response.json();
            
            isGenerating = false;
            cancelAnimationFrame(animationFrameId);
            
            if (response.status !== 200) {
                throw new Error(data.message || data.error || 'API 请求失败');
            }

            // 5. 显示结果
            const resultUrl = data.output.choices[0].message.content[0].image;
            
            loadingText.innerText = "渲染完成！";
            loadingSubText.innerText = "下载结果中...";
            
            const resultImg = new Image();
            resultImg.crossOrigin = "Anonymous"; 
            resultImg.onload = function() {
                ctxResult.drawImage(resultImg, 0, 0, canvasSize, canvasSize);
                
                simulationCanvas.style.opacity = '0';
                resultCanvas.style.opacity = '1';
                
                loadingOverlay.classList.add('hidden');
                document.getElementById('generateBtn').disabled = false;
                updateStatus('生成完毕！', 'green');
                maskCanvas.style.opacity = '0';
            };
            resultImg.src = resultUrl;

        } catch (error) {
            isGenerating = false;
            loadingOverlay.classList.add('hidden');
            document.getElementById('generateBtn').disabled = false;
            maskCanvas.style.opacity = '0.7'; 
            
            alert(`生成失败: ${error.message}`);
            updateStatus('生成失败', 'red');
            console.error(error);
        }
    }

    function updateStatus(text, color = 'gray') {
        const dot = document.getElementById('statusDot');
        const txt = document.getElementById('statusText');
        
        const colors = {
            'gray': 'bg-slate-500',
            'green': 'bg-green-500',
            'blue': 'bg-blue-500',
            'red': 'bg-red-500'
        };

        dot.className = `w-2 h-2 rounded-full ${colors[color]}`;
        txt.innerText = text;
        
        txt.classList.add('text-white');
        setTimeout(() => txt.classList.remove('text-white'), 500);
    }

    init();
</script>
</body>
</html>
